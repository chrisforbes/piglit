# Try reading from more vertices in the tessellation control shader than
# the input patch size.
#
# From the ARB_tessellation_shader spec (Section 2.X.1.2, Tessellation
#                                        Control Shader Inputs):
#
#       Behavior is undefined if gl_in[] is indexed with a vertex index
#       greater than or equal to the current patch size.
#
# So just test that the test doesn't crash.
#
[require]
GLSL >= 1.50
GL_ARB_tessellation_shader


[vertex shader]
void main()
{
	gl_Position = vec4(0);
}


[tessellation control shader]
#extension GL_ARB_tessellation_shader: require
layout(vertices = 32) out;

void main() {
	gl_out[gl_InvocationID].gl_Position = gl_in[gl_InvocationID].gl_Position;
	gl_TessLevelOuter = float[4](1.0, 1.0, 1.0, 0.0);
	gl_TessLevelInner = float[2](1.0, 0.0);
}


[tessellation evaluation shader]
#extension GL_ARB_tessellation_shader: require
layout(triangles) in;

void main() {
	gl_Position = vec4(0);
	for (int i = 0; i < 32; ++i)
		gl_Position += gl_in[i].gl_Position * gl_TessCoord[i % 3];
}


[fragment shader]
void main()
{
	gl_FragColor = vec4(0.0, 1.0, 0.0, 1.0);
}

[test]
patch parameter vertices 1
draw arrays GL_PATCHES 0 256
draw arrays GL_PATCHES 0 512
draw arrays GL_PATCHES 0 1024
draw arrays GL_PATCHES 0 2048
patch parameter vertices 2
draw arrays GL_PATCHES 0 256
draw arrays GL_PATCHES 0 512
draw arrays GL_PATCHES 0 1024
draw arrays GL_PATCHES 0 2048
